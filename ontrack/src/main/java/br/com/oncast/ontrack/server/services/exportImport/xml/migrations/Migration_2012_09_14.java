package br.com.oncast.ontrack.server.services.exportImport.xml.migrations;

import br.com.oncast.ontrack.server.services.exportImport.xml.abstractions.Migration;

import java.util.ArrayList;
import java.util.List;

import org.dom4j.Attribute;
import org.dom4j.Element;

/**
 * Changes:
 * <ul>
 * <li>Removes timestamp from ScopeDeclareProgressAction
 * <li>Moves TeamInviteActions generated by {@link Migration_2012_03_15} as first actions
 * </ul>
 * 
 */
public class Migration_2012_09_14 extends Migration {

	private static final String SCOPE_DECLARE_PROGRESS_ACTION = "br.com.oncast.ontrack.shared.model.action.ScopeDeclareProgressAction";
	private static final String TEAM_INVITE_ACTION = "br.com.oncast.ontrack.shared.model.action.TeamInviteAction";

	@Override
	protected void execute() throws Exception {
		removeTimestampFromScopeDeclareProgressAction();
		moveGeneratedTeamInviteActionsToBegining();
	}

	private void removeTimestampFromScopeDeclareProgressAction() {
		for (final Element action : getElementsWithClassAttribute(SCOPE_DECLARE_PROGRESS_ACTION)) {
			final Attribute attribute = action.attribute("timestamp");
			if (attribute != null) action.remove(attribute);
		}
	}

	private void moveGeneratedTeamInviteActionsToBegining() {
		final Element adminUserAction = getAdminInviteUserAction();
		if (adminUserAction == null) return;

		final List<Element> inviteActionListToBeMoved = getConsecutiveTeamInviteActionsAfter(adminUserAction);

		moveToBegining(adminUserAction, inviteActionListToBeMoved);
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private void moveToBegining(final Element adminUserAction, final List<Element> inviteActionListToBeMoved) {
		final Element userActionsList = adminUserAction.getParent();
		final List elements = userActionsList.elements();
		for (final Element action : inviteActionListToBeMoved) {
			elements.remove(action);
			elements.add(0, action);
		}
		userActionsList.setContent(elements);
	}

	@SuppressWarnings("unchecked")
	private List<Element> getConsecutiveTeamInviteActionsAfter(final Element adminUserAction) {
		final List<Element> consecutiveTeamInviteActions = new ArrayList<Element>();

		final List<Element> userActionsList = adminUserAction.getParent().elements();
		for (int i = userActionsList.indexOf(adminUserAction) + 1; i < userActionsList.size(); i++) {
			final Element userAction = userActionsList.get(i);
			if (!isTeamInviteAction(userAction)) break;
			consecutiveTeamInviteActions.add(userAction);
		}
		for (int i = userActionsList.indexOf(adminUserAction); i >= 0; i--) {
			final Element userAction = userActionsList.get(i);
			if (!isTeamInviteAction(userAction)) break;
			consecutiveTeamInviteActions.add(0, userAction);
		}
		return consecutiveTeamInviteActions;
	}

	private boolean isTeamInviteAction(final Element userAction) {
		return TEAM_INVITE_ACTION.equals(userAction.element("action").attributeValue("class"));
	}

	private Element getAdminInviteUserAction() {
		for (final Element action : getElementsWithClassAttribute(TEAM_INVITE_ACTION)) {
			final String inviteeEmail = action.element("inviteeEmail").attributeValue("id");
			if (inviteeEmail.equals("admin@ontrack.com")) { return action.getParent(); }
		}
		return null;
	}
}
